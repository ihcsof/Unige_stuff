What does Alice compute before signing a message? * sign(M) * h(M) * SkA * 2
Which of the following is NOT a property of a digital signature? * Authentication * Non-repudiation * Encryption * 3
What is a ledger primarily used for? * Managing employee records * Reconciling balances * Tracking customer satisfaction * 2
What do hash pointers of prev blocks in blocks allow? * To check the integrity of the information * To store new coins * To track transaction times * 1
What distinguishes decentralized systems from distributed systems? * Location and redundancy * Control * Both location and control * 3
All ?? must be ??, but ?? are not necessarily ?? * decentralized, distributed, distributed, decentralized * decentralized, distributed, decentralized, distributed * distributed, decentralized, decentralized, distributed * 1
Why are decentralized systems often considered more chaotic? * They have a central authority * Actors work independently without responding to an authority * They rely on monocultures * 2
What is a replicated linked list of blocks secured through cryptography commonly called? * Blockchain * Transaction * Wallet * 1
What is a characteristic of permissioned blockchains? * Anyone can read and write * A central entity assigns rights to peers * It is always public * 2
What type of blockchain storage is typically used in mobile devices? * Full blockchain * Pruned blockchain * Simplified payment verification (SPV) clients * 3
What does a Bitcoin wallet ("bank account") require to send and receive Bitcoins? * Two math connected private key and a public key * Only a public key * An Internet connection and a username * 1
What does the Bitcoin protocol use to compute keys for digital signatures? * RSA * Elliptic curve cryptography (ECC) * Hash functions * 2
What is the result of adding two points on an elliptic curve? * A new point on the curve * The inverse of the original point * A point off the curve * 1
How is a public key (Pk) computed in ECC? * By adding two private keys * By multiplying a base point (G) with the private key (Sk) * By reflecting the base point on the x-axis * 2
What is a Bitcoin address derived from? * The private key * The public key using two hash functions * The wallet's IBAN * 2
How is a Bitcoin address generated? * By applying two hash functions (RIPEMD160 and SHA256) to the public key and encoding it in Base58 * By encoding the private key directly in Base58 * By applying only the SHA256 function to the wallet identifier * 1
How is any bitcoin wallet identified? * By means of a private key, obtained from the public key, and the bitcoin address that once hashed represents the wallet * By means of a bitcoin address, obtained by hashing the private key, and the public key obtained by the ECC multiplication * By means of a bitcoin address, obtained by hashing the public key produced by ECC multiplication of the private key * 3
What happens if you lost the Sk? * Everything is lost * Everything is lost and you're dumb * You can reverse the process with the seed phrase * 3
What does a non-custodial wallet provide to the owner? * Access to their public key only * Full control over their private keys and assets * Control over keys managed by a third party * 2
What is an UTXO? * A transaction that has been fully spent * A transaction that has not yet been spent * A transaction that is pending approval * 2
What does the input of a Bitcoin transaction include? * The recipient’s digital signature * The sender’s digital signature and the transaction ID of a previous transaction * The amount of Bitcoin being transferred * 2
What does the output of a Bitcoin transaction consist of? * The recipient's address and a lock script * The sender's private key * The transaction's creation date * 1
What can Bob do if he wants to pay 30 BTC but hasn't received any single transaction of that amount? * He cannot complete the transaction * He can combine multiple smaller transactions he has previously received * He must go live under the bridge * 2
What primarily determines the transaction fee in the Bitcoin network? * The total amount spent * The weight of the transaction in terms of KB * The sender's reputation * 2
What does a high mempool size indicate about network traffic? * Decreased transaction fees * Increased network traffic and longer confirmation times * Fewer transactions being processed * 2
What is the role of miners in the Bitcoin ecosystem? * Storing transactions * Adding new blocks of valid transactions and creating new Bitcoins * Validating transactions with rewards * 2
What type of hardware is commonly used today for hashing in mining? * CPU * ASIC * GPU * 2
What do mining pools do? * Provide individual miners with their own blocks * Distribute hash power across individual miners * Compute hashes to collectively earn rewards * 3
What are the initial steps a miner must take to validate transactions in the Bitcoin network? * Listen for transactions, ensure no double-spending occurs, and verify digital signatures * Group transactions into a block, , ensure no double-spending occurs and broadcast it to the network * Establish a mining pool, verify the block reward and verify digital signature * 1
What is the purpose of the NONCE in Proof-of-Work? * It adds complexity to the transaction validation process * It is a random number miners must find to solve the hash puzzle * It determines the size of the block * 2
How is the Difficulty adjusted in Bitcoin’s Proof-of-Work mechanism? * Based on the number of transactions in each block * According to the time required to mine the last 2016 blocks compared to a target of 20160 minutes * Automatically every 4 years during halving * 2
To encourage their work, miners receive incentives (rewards): fees of the transactions contained in the block (priority to the transactions with ?? fees), newly created Bitcoins (?? transaction) * highest, miner * lowest, miner * highest, coinbase * 3
What will happen to blocks in the shorter chain during a fork? * They are surely kept in the blockchain * They are surely canceled and return to the mempool * They might create a new chain but probably they will be canceled and return to the mempool * 3
What makes the blockchain immutable? * Digital signatures * Hash pointers * Sequential numbering * 2
What is a true sentence about Merkle trees? * They help to verify the total number of transactions * They help to verify the integrity of any transaction * A branch of the tree is enough to check whether any transaction of the block has been modified * 2
What is the method used by X to verify the validity of a Bitcoin transaction T contained in a block? * He checks the digital signature of the sender * He requests the hashes of each sibling and recomputes the root * He compares the transaction ID with a known list * 2
How do miners ensure that each block they produce generates different hashes during mining? * By changing the transaction inputs in the block * By modifying the nonce and extra-nonce fields in the Coinbase transaction * By adjusting the timestamps of the transactions in the block * 2
What identifies users in the Bitcoin blockchain and how are peers identified in the Bitcoin network? * Users are identified by their wallet balances and peers by their geographical location * Users are identified by their public key/address and peers by their IP or Onion addresses * Users are identified by their transaction history and peers by their node type * 2
What types of peers exist in the Bitcoin network concerning connectivity? * Listening peers and non-listening peers * Active peers and passive peers * Centralized peers and decentralized peers * 1
What distinguishes the reachable network from the nonreachable network in the Bitcoin ecosystem (then there's the extended)? * Reachable nodes do not use the Bitcoin protocol * Reachable nodes listen for incoming connections while nonreachable nodes do not * Nonreachable nodes can broadcast transactions * 2
How does the Bitcoin network mitigate transaction flooding and block flooding? * By relaying all transactions without validation * By requiring fees for any transaction and only relaying valid blocks * By requiring fees for valid transactions and only relaying valid blocks * 3
How do Bitcoin nodes discover their public IP address when joining the network? * They send a GET request to two hard-coded websites * They can be hardcoded * Both * 3
What mechanism do Bitcoin nodes use to maintain connections with peers? * They randomly disconnect from all peers * They always select new nodes from a fixed list * They try to maintain 8 outgoing connections and select new nodes when neighbors leave * 3
How do Bitcoin nodes propagate addresses of other peers in the network? * By sending requests for IP addresses only to the central server * By forwarding unsolicited ADDR messages and responding to GETADDR requests * By broadcasting their own IP addresses every 1.30 minutes * 2
What is the process a Bitcoin node follows when it creates a transaction? * It serializes it in hexadecimal format and announces it using a GETDATA message * It serializes it in hexadecimal format and announces it using an INVENTORY message * It sends it directly to the miner for validation * 2
How do Bitcoin nodes handle transaction requests in the propagation process? * They keep a static list of transactions for all peers * They request the transaction using a TX message * They send a GETDATA message to request specific transactions when they receive an INVENTORY message * 3
What components does a miner include when creating a new block after finding a nonce? * The block header, a list of transactions, and the Merkle root * The block header, only the first transaction, and the miner's signature * A timestamp, a nonce, and the network fees * 1
How do neighboring nodes respond upon receiving an INVENTORY message advertising a new block? * They immediately forward the block to their peers * They check if they already have the block and respond with a GETDATA request if they do not * They ignore the message and continue mining because here's comes the moooney! * 2
What does a node verify to ensure a transaction is valid? * The input Bitcoins haven't been spent yet * The output Bitcoins exceed the input * The transaction was broadcasted by the miner * 1
What is the defining characteristic of Bitcoin Script as a programming language? * It is a stack-based language where each instruction is executed exactly once, processing transactions in a linear, one-time execution model * It is an object-oriented language allowing for the definition of transaction objects that can be manipulated by methods * It is a functional language enabling recursion and higher-order functions to manage complex transaction logic * 1
What advanced features does Bitcoin Script allow for in transaction validation? * It supports multi-signature wallets, escrow payments, and time-locked transactions, ensuring more secure and flexible control over Bitcoin outputs * It enables automated decentralized voting mechanisms for governance and staking models * It implements zero-knowledge proofs for complete transaction privacy and anonymity * 1
How do Bitcoin nodes ensure the security and validity of transaction scripts? * By running every script in a sandbox environment to detect possible malicious activity in real-time * By using machine learning models to analyze the behavior of scripts and prevent unauthorized transactions * By using a predefined list of standard scripts and rejecting non-standard ones, limiting the potential for complex or malicious operations * 3
What is required for a Bitcoin transaction to be valid? * The transaction must contain at least two digital signatures from different nodes * The locking script and unlocking script must be concatenated and execute successfully * The scripts must be signed by the Bitcoin network administrators * 2
For a Pay-to-PubKey-Hash (P2PKH) script, when is a Bitcoin transaction deemed invalid? * If the final stack contains more than one element * If the top element is non-zero * If the transaction includes more than two signatures * 1
What is the Pay-to-Pubkey (P2PK) script pattern, which locks an output to a public key (longer than a Bitcoin address), commonly found in Coinbase transactions in earlier blocks of the blockchain, and indicates that if OP_1 appears in the output script, it is likely associated with SegWit outputs? * a pattern that locks to a private key * a script pattern that locks to a public key * a pattern that locks to a Bitcoin address * 2
In ?? a third party (escrow/arbiter) may optionally be involved in transactions. To unlock this type of script, a required number of signatures need to be provided among a set of specified public keys * Pay-to-PubKey-Hash * Pay-to-PubKey * Pay-to-Multisig * 3
The ?? standard locking script is used for storing data on the blockchain, which includes the instruction ?? that returns immediately with an error, preventing the processing of any subsequent instructions, and allows for a maximum of 80 bytes of data * NULL DATA, OP_RETURN * NULL DATA, OP_POP * OP_POP, NULL DATA * 1
What's a good way to store data permanently on the blockchain? * You can delete the back pointer of the previous transaction to split the chain * You use Pay-to-Multisig * With an OP_RETURN in the transaction you can "burn coins" as ashses because they can't be recovered (proof-of-burns) * 3
??, which serve as design documents that provide essential information to the Bitcoin community, describe new features or processes related to Bitcoin * Bitcoin Feature Proposals (BFPs) * Bitcoin Improvement Proposals (BIPs) * Bitcoin Feature Addition (BFAs) * 2
What are the key differences between a hard fork and a soft fork in Bitcoin protocol changes? * a hard fork allows for backward compatibility while a soft fork does not * a hard fork requires all nodes to upgrade, whereas a soft fork requires only a majority to upgrade * a hard fork results in temporary divergence while a soft fork causes permanent divergence * 2
What is the purpose of the Segregated Witness (SegWit) protocol upgrade? * SegWit enhances privacy and security features in Bitcoin transactions * SegWit reduces transaction fees for all users on the Bitcoin network * SegWit enables larger block sizes and mitigates transaction malleability * 3
How does Bitcoin's malleability issue allow the alteration of digital signatures while a transaction remains unconfirmed, leading to a situation where the signature remains mathematically valid but results in a different hash, thereby changing the transaction identifiers? * It creates an immutable record for all transactions, ensuring reliability * It enables multiple valid transaction identifiers for the same transaction, potentially leading to invalidation of dependent transactions * It ensures that the Bitcoin network remains decentralized and secure by preventing alterations * 2
What is one of the main differences between Legacy and SegWit in terms of how transaction data is processed in Bitcoin, particularly with regard to witness data and block capacity? * SegWit separates witness data and increases block capacity, while Legacy includes witness data in the base block * Legacy allows the transaction ID to be calculated from witness data, while SegWit excludes it from the calculation * SegWit does not support backward compatibility with the original Bitcoin protocol, while Legacy does * 1
How are legacy and SegWit blocks measured, and what is one of the key differences in how miners handle them? * Both Legacy and SegWit blocks are measured by weight, but miners prioritize Legacy blocks for backward compatibility * Legacy blocks can strip witness data for lower weight, while SegWit blocks include all witness data * Legacy blocks are measured by size, while SegWit blocks are measured by weight, and miners favor SegWit transactions due to lower weight * 3
What does the Taproot upgrade introduced in Bitcoin in November 2021 achieve, and how does it improve the network? * It improves privacy, scalability, and security through Schnorr signatures, MAST, and new opcodes while being implemented as a soft fork * It increases transaction speed and lowers fees by reducing the block size * It introduces a new consensus mechanism, replacing Proof of Work * 1
What is a key characteristic of the Proof-of-Stake (PoS) consensus mechanism compared to Proof-of-Work (PoW)? * Blocks are mined and require solving complex mathematical puzzles * Validators forge blocks based on their economic stake in the network * PoS uses miners to validate transactions and form new blocks * 2
How are rewards distributed in a mining pool? * Based on the amount of work done by each miner, with the coordinator keeping a fee * Every miner is paid equally, regardless of their contribution * Only the coordinator receives the rewards, and they distribute them as they wish * 1
What can a 51% attacker achieve in a Bitcoin network? * Create a fork and double-spend * Freeze their own wallet * Launch new cryptocurrencies * 1
How feasible are 51% attacks today, considering the current Bitcoin hash rate? * Impossible due to high security protocols * Very feasible as Bitcoin mining is cheap * Feasible for a powerful player with significant resources * 3
What happens when a selfish mining pool is ahead by one block and honest miners find a block? * They keep mining privately * They immediately publish their secret block * They abandon their private fork * 2
What does the selfish mining pool do if they are more than two blocks ahead of honest miners? * They reveal one of their withheld blocks to get a reward * They publish their entire private chain * They stop mining temporarily * 1
What is a Sybil attack in P2P systems? * Creating many nodes to subvert the system * joining the BTC network and propagating only attacker's block, therby raising gamma (fraction of honest nodes that work on the selfish fork) * both * 3
In the ?? analysis of the selfish mining: numbers are the ??, the 0' state is the ?? in which a fraction gamma of honest nodes works on the attacker's fork and we want to find the equilibrium distribution, associating a reward to each transition * probability, joiners, initial state * markov chain, selfish fork's lead, tie situation * both * 2
In the selfish mining prob distribution we have that (only) before pool_size=0.25 the curve with gamma=?? is behind the honest mining * 0 * 1/2 * 1 * 2
Some cryptocurrencies (e.g Eth) reward linking “orphan” blocks in the blockchain (they become "uncle" blocks), is this good or bad for selfish mining? * Bad, this is a solution to prevent it * selfish's lose when they lose ties, so when blocks become orphan. If they get uncle they benefit from it just as honests do, so there's a balance and nothing changed * Good, this enables selfish mining * 2
In which situation the selfish pool loses? * Gain one more block * Honest gain one block in selfish fork * Honest gain one block in honest fork * 3
In an eclipse attack, how is the attacker positioned relative to the attacked node? * Physically between the attacked node and others * In the P2P overlay, not physically between nodes * Between the node and its internet connection * 2
How can an eclipse attack facilitate a 51% attack with less mining power? * By hiding transactions from miners * By preventing block relaying between miners * By directly altering the blockchain's consensus rules * 2
In a double-spending attack using an eclipse, what happens to the first transaction? * It is included in the longest blockchain and confirmed * It is overwritten in the same block as the second transaction * It is in a shorter chain and gets canceled * 3
What is the role of the “first 16 bits” in the "Tried" and "New" tables mechanism? * It identifies the node’s IP address * It selects which group a node is assigned to for bucket allocation * It hashes the node’s full address to assign it to a table * 2
What is the strongest countermeasure against Eclipse Attacks in Bitcoin's client? * Group hashing based on IP addresses * Random node connections * Encryption of all node communications * 1
Why are botnets considered dangerous in the context of Eclipse Attacks? * They can bypass encryption protocols * They offer large IP diversity, making the attack more effective * They allow attackers to control mining pools * 2
How do botnet-controlled devices contribute to the success of Eclipse Attacks? * They generate massive amounts of data * They provide IP diversity to fill more buckets in Bitcoin's node tables * They break Bitcoin's hashing algorithm * 2
What is the eviction policy countermeasure against Eclipse Attacks in Bitcoin? * Evict the node with the oldest timestamp * Hash the IP to determine a single slot in the bucket * Randomly evict nodes based on peer selection * 2
What is the purpose of "Test Before Evict" in countering Eclipse Attacks? * To verify that nodes are responsive before evicting them from the Tried table * To increase the size of the Tried table * To randomly evict non-responding nodes without testing * 1
Link each of the features to a speific btc countermeasure: random instad of fresher, 256 to 1024 New's, inspired by Tor, hash IP to get a single slot in the bucket, probability of success plateaus lot before for the attacker, cclean trash from New * Eviction, More buckets, Anchor Connections, Peer Selection, Feeler Connections * Peer Selection, More buckets, Anchor Connections, Feeler Connections, Eviction * Peer Selection, More buckets, Anchor Connections, Eviction, Feeler Connections * 3
The Ethereum P2P network consists of interconnected nodes that collectively form the ??, enabling cryptocurrency exchanges and the execution of ??. * Ethereum Virtual Machine (EVM), smart contracts * EVM, transactions * blockchain, transactions * 1
Smart contracts are written always in Solidity, compiled into EVM bytecode with its own instruction set, enabling operations like arithmetic, memory access, and control flow using instructions like JUMP * true * false, in various languages * false, EVM is not bytecode * 2
What is a snapshot of the blockchain at a given time, reflecting account balances, smart contract storage, and data, which changes when a transaction is processed and added to the blockchain? * a block * the state * a transaction * 2 
Each full node on the Ethereum network must store the entire state of the Ethereum system, including smart contract bytecode, all inputs and outputs, and communications among smart contracts * true * false, it's decentralised * false, it's a blockchain not a network * 1
Ethereum has two types of accounts: ??, which are like Bitcoin accounts controlled by key pairs and can send transactions with a nonce, and ??, controlled by contract code, which can manage internal storage, interact with other contracts, and create new contracts * Contract Accounts (CAs), Externally Owned Accounts (EOAs) * Centralised Accounts (CAs), Externally Owned Accounts (EOAs) * Externally Owned Accounts (EOAs), Contract Accounts (CAs) * 3
?? uses an account-based model (e.g banks) where transactions adjust account balances, and nonces are incremented to prevent replay attacks by ensuring each transaction is unique * Bitcoin * Ethereum * both * 2
To deploy a smart contract, a transaction with EVM bytecode is sent to address ??, and the contract becomes accessible at an address derived from the sender's address and their transaction ?? * 0, id * 0, nonce * 1, nonce * 2
Interacting with on-chain applications requires users to pay a fee, called ??, which measures the computational effort needed to execute operations on Ethereum * gas * eth fee * gwei * 1
The EVM is a Turing-complete machine limited by the gas required to execute instructions, and the gas price determines ??, without affecting the gas needed for the transaction * how long the execution will take * for how long the transaction will stay on the blockchain * how much users pay per unit of gas * 3
The gas limit is the maximum gas a user is willing to spend on a transaction, acting as a safeguard against excessive gas use, and any unused gas below the limit is returned to the sender * true * there's no mechanism like that * there's this mechanism but the gas below the limit is indeed lost * 1
Why would a user choose to pay a high gas price when they can choose to pay the minimum? * In fact this doesn't happen :) * Higher gas leads to faster transaction confirmation * They're more trustworthy * 2
Before the ??, users could set their own transaction fees, leading to high costs during congestion, but afterward, a base fee system was introduced, where the protocol computes fees, increases them based on block congestion, and ?? the base fee to help reduce supply and potentially increase ETH's value * London upgrade, burns * London upgrade, include * 2016, include * 1
London upgrade (EIP-1559) changes displeased many miners as it reduced their rewards for completing new blocks, why? * base fee was now burned * high fees are no more! * due to the priority fee to expedite their transactions * 1
How did Ethereum's Ethash Proof-of-Work algorithm ensure ASIC resistance and fair mining competition? * By requiring miners to download a large DAG file, compute the Keccak-256 hash, and continuously update it with each new block * By dynamically adjusting the DAG size to prevent DAG file manipulation, forcing miners to store multiple datasets simultaneously * By creating orphan blocks to delay transaction finalization, discouraging high-speed ASIC miners from participating in the network * 1
How does Ethereum's Ethash PoW adjust difficulty? * By increasing the DAG size every epoch to slow down mining * By dynamically adjusting the difficulty so that one block is produced every 12-15 seconds * By changing the Keccak-256 hashing algorithm based on miner performance * 2
How are validators selected in Ethereum’s Proof-of-Stake system? * By staking the largest amount of ETH * By being randomly selected from the pool of active validators using a pseudo-random function * By volunteering for each block * 2
What happens if a validator proposes an invalid block in Ethereum's PoS? * They receive a reward deduction * Their stake is reduced by half * Some of their locked ETH is burned, a process called slashing * 3
How does Ethereum’s Proof-of-Stake prevent centralization of power? * By having a fixed committee for each epoch * By randomly forming new committees (that propose blocks and attest their validity) of 128 members each epoch * By increasing the required stake amount * 2
Blockchain trilemma is: decentralization, security and ?? * verifiability * scalability * avaibility * 2
What is a role of protocol tokens like ETH and BTC? * Preventing transaction spam and keeping the network safe from attacks * Facilitating high-speed transactions only * For making applications run faster * 1
What are second-layer tokens in Ethereum? * Tokens created for security purposes * Tokens created via smart contracts or issued on Layer 2 networks * Tokens limited to protocol-level use only * 2
How can decentralized applications (dApps) be compared to something familiar? * Like individual computers in a network * Like websites running on the internet * Like physical stores in a mall * 2
What are ICOs (Initial Coin Offerings) used for? * Distributing centralized ownership of dApps * Funding projects by selling tokens * Issuing government bonds * 2
What are the typical steps for running an ICO? * Create the product, hire developers, set a budget * Create tokens, write a white paper, establish a web and social presence * Develop the code, acquire venture capital, apply for a patent * 2
What makes ERC-20 tokens unique compared to other tokens? * They are not unique, each token is identical in type and value * They represent physical goods * They can store images and files * 1
Which functionality is NOT part of ERC-20 tokens? * Transferring tokens between accounts * Delegating accounts to spend tokens * Representing unique items like art or real estate * 3
How does Ethereum's state machine store the world state? * As a mapping between account addresses and account states * As a list of transactions * As a flat file of balances * 1
How does the Ethereum Proposer produce and validators verify a block during the consensus process? * The Proposer sequentially applies state changes from transactions Tx[0]...Tx[n-1], updating the world state for each, and records the new state in the block. Validators then re-execute all transactions to independently verify the correctness of state changes and, if valid, they sign the block, leading to epoch finalization once enough signatures are collected. * Validators skip re-executing the transactions and only check the Proposer’s state updates before signing. * The Proposer applies random state changes and validators approve them without re-execution. * 1
What data structure is used to store the world state in Ethereum? * Hash table * Linked list * Merkle Patricia Trie * 3
What are smart contracts and how do they function within the Ethereum ecosystem? * Smart contracts are private agreements between parties that do not execute automatically. * Smart contracts, defined by Nick Szabo in 1993, are self-executing digital agreements that contain protocols for communication and performance, operating under a set of promises (IF...THEN...ELSE). In Ethereum, they enable the largest ecosystem of decentralized applications (dApps), are public and transparent, allowing for code reuse, but their effectiveness depends on the developers, as any bugs in the code remain on the blockchain permanently. * Smart contracts only function in centralized networks and are not reusable by dApps. * 2
What are the implications of Turing completeness and execution methods on Ethereum (ETH) and Bitcoin (BTC) regarding contract execution and security? * Ethereum's Turing completeness allows any instruction to run, providing maximum freedom but increasing the likelihood of mistakes; its off-chain execution means contract code is not stored on the blockchain, allowing for coordinated code distribution, which minimizes errors. In contrast, Bitcoin employs restricted instructions for limited, purpose-specific actions, making it harder to make mistakes and more secure against hacking; its on-chain execution ensures contract code is stored on the blockchain and subject to consensus, promoting transparency. * Off-chain execution increases security risks in Ethereum. * both * 1
In solidiy data locations are: ??: for permanent data (stored on blockchain, expensive), ??: used to save temporary variables during function execution (often required in return parameters), ??: non-modifiable and non-persistent data location, default location for function arguments * Storage, Memory, Calldata * Memory, Storage, Calldata * Calldata, Memory, Storage * 1
The amount of gas used during a transaction depends on ?? * the number of operations * the data location used in the smart contract * the amount of eth exchanged * 2
?? variables are initialized at compile time, stored in the contract's bytecode, they can be accessed without accessing the contract's storage and they do not consume any gas when accessed, since they do not require a storage read * constant * immutable * global * 1
?? variables are initialized during contract deployment, in the contract constructor. They're saved in the bytecode, they are useful for storing values such as addresses, hashes, ... * constant * immutable * global * 2
?? variables are stored in contract storage, are accessible from all functions in the contract (e.g built-in vars) * constant * immutable * global * 3
In Solidity, a ?? is a synchronous, gas-free, read-only operation that invokes view or pure functions locally without broadcasting to the blockchain, using the JSON-RPC method eth_call * call * transaction * both * 1
A ?? is an asynchronous, gas-consuming write operation broadcast to the network, processed by validators, and, if valid, added to a block, with an immediate return of the transaction hash via the JSON-RPC method eth_sendTransaction * call * transaction * both * 2
SOlidy compiler produces: * bytecode executable on EVM * Application Binary Interface (ABI), e.g., an interface to interact with the EVM bytecode (JSON-like syntax) * both * 3
In Solidity you need to bind with an Eth node e.g a blockchain data keeper ?? become a node yourself (JSON RPCs are used as middleware in Web3 Interface frontend to the ETH P2P net) * AND * AND NOT * OR * 3
Why are transaction logs considered more efficient for data storage than contract storage in Solidity? * They are stored off-chain, reducing overall data costs * They are only accessible within smart contracts * They are stored in a separate blockchain area with lower storage costs * 3
Smart contract verification is a process to ensure transparency and security by matching the contract’s source code to its ? ?, achieved by compiling the Solidity code, deploying it to a testnet, and verifying it on a blockchain explorer like Etherscan with necessary details and settings * on-chain, bytecode * off-chain, source code * on-chain, source code * 1
? tokens are interchangeable, divisible assets that can be transferred between accounts, allowing users to check balances, total supply, and third-party spending permissions, implemented via a standard API with required functions like totalSupply, balanceOf, transfer, approve, and optional fields such as name and symbol; only the owner can mint or burn tokens * ERC-721 * NFT's * ERC-20 * 3
? tokens represent ownership of unique assets (e.g., images) with metadata stored off-chain in JSON format containing details like name, description, and file link, along with traits for uniqueness and rarity; in generative collections, traits are algorithmically combined to create distinct NFTs, which are minted on-chain despite being stored off-chain * ERC-721 * NFT's * both * 3
? tokens enable multiple token types within a single contract, reducing blockchain space and gas costs, supporting batch transfers for efficient multi-token transactions, and allowing atomic swaps for trustless exchanges—features that make it ideal for applications like gaming * ERC-1155 * ERC-721 * ERC-20 * 2
What major flaw was exploited in "The DAO" in 2016? * Infinite loop * Overflow bug * Reentrancy vulnerability * 3
What governance method do DAOs typically use? * Token-based voting power * Centralized decision-making * Random selection * 1
What was the primary purpose of "The DAO"? * Serve as a decentralized insurance fund * Act as a decentralized venture capital fund * Develop new blockchain protocols * 2
What was the outcome of the Ethereum hard fork after "The DAO" exploit? * It transferred funds back to DAO investors * It allowed the attacker to keep all stolen funds * It permanently froze the stolen funds * 1
How can you solve the SIMPLE reentrancy vulnerability in the withdrawal that is called again at each funds receive? * shift the balance = 0 above the fund send call *  lock the script with a noReentrancy modifier * we've seen both * 3
What controversial principle did the Ethereum hard fork contradict? * Immutability of tokens * Centralized control * Code is law * 3
What is unique about flash loans in DeFi? * They are free of interest * They must be borrowed and repaid in a single transaction * They require collateral * 2
What tactic did the attacker use in the Beanstalk exploit with flash loans? * Increased gas fees * Wash trading * Gained voting control to modify the code * 3
What does frontrunning exploit in DeFi transactions? * Delayed transaction finalization * Increased transaction speed * Zero-fee transactions * 1
How does the "refund transaction" protect funds in one-way channels? * It enables immediate withdrawal * It allows funds to be reclaimed after a set lock time if B doesn’t respond * It ensures all funds are automatically refunded after each transaction * 2
In one-way channels, what incentivizes party B to close the channel? * Receiving a refund automatically * The increasing value in the latest spending transaction * The ability to open a new channel * 2
How does the Bitcoin Lightning Network reduce congestion on the blockchain? * By settling payments off-chain through incremental balance updates * By limiting the number of users * By requiring blockchain validation for every transaction * 1
What advantage do bidirectional channels offer over one-way channels? * They require fewer blockchain confirmations * They allow for two-way, ongoing transactions without channel expiration * They use fewer smart contract functions * 2
What function does OP_CHECKLOCKTIMEVERIFY provide? * It locks outputs for a minimum number of confirmations before they can be spent * It automatically refunds transactions after a set period * It cancels transactions after each confirmation * 1
How does a revocation key prevent outdated transactions from being used? * It allows either party to invalidate previous states * It is used to confirm each transaction immediately * It prevents the creation of new transaction states * 1
Why must parties in bidirectional channels stay online? * To prevent outdated states from being broadcasted * To approve each transaction in real-time * To avoid creating revocation keys * 1
How does an Elkrem tree optimize the storage of revocation secrets? * By storing all revocation keys in a single transaction * By enabling each secret to be derived from a root key, reducing storage to O(log n) * By compressing revocation keys into the transaction log * 2
What problem does a Hash Time-Locked Contract (HTLC) solve in multi-hop transfers? * Prevents Bob from keeping funds intended for Carol * Speeds up transactions between Alice and Carol * Reduces transaction fees for intermediary nodes * 1
In an HTLC, what must the receiver provide to claim funds? * A valid transaction ID * The payer's digital signature * Cryptographic proof (preimage) of a hash * 3
Why is channel capacity a limiting factor in multi-hop transfers? * Nodes must have enough funds to forward payments * Only large transactions are supported * Funds are permanently locked in channels * 1
What does the Lightning Network’s gossip protocol achieve? * It shares information about available payment channels * It encrypts all transaction data for privacy * It eliminates the need for fees in multi-hop transfers * 1
What is the purpose of OP_CHECKSEQUENCEVERIFY in a Lightning Network script? * Checks the identity of both parties * Enforces a time delay without consuming the stack * Locks the funds permanently on the stack * 2
What enables cross-chain swaps between two different blockchains? * Digital signatures * Channel capacity * Hash Time-Locked Contracts (HTLCs) *  3
What does the elliptic curve trick achieve in multi-signature setups? * It combines two key pairs to form a new one * It splits a private key into multiple parts * It automatically invalidates older transactions * 1
? addresses the centralized control and data privacy issues of today's internet by introducing a blockchain-based decentralized state layer, marking a ? revolution * Web2, back-end * Web3, front-end * Web3, back-end * 3
? prioritizes decentralization with features like verifiability, self-governance, permissionless access, and native payments, enabling service producers and consumers to transact directly, rewarding network participants who sustain and secure the ecosystem * Web3 * Ethereum * Blockchain * 1
Is the order of Ethereum stack right?: the EVM at its core, Ethereum nodes for blockchain state and consensus, smart contracts, client APIs for developer interaction, and standard web or mobile end-user applications * yes * no, 2 has to be exchanged with 3 * no, 3 has to be exchanged with 3 * 2
? is the first JavaScript library for interacting with the Ethereum blockchain, offering APIs for blockchain operations, smart contracts (web3-eth), P2P communication (web3-shh), decentralized storage (web3-bzz), and utility functions for dApp development (web3-utils) * ether.js * web3.js * infura * 2
Ethers.js is a JavaScript library for interacting with the Ethereum blockchain, featuring classes like ? for read-only blockchain access, ? for interacting with deployed contracts as JavaScript objects, and ? for signing messages and transactions to perform write operations, supporting both custodial and non-custodial accounts * Provider, Contract, Signer * Contract, Provider, Signer * Provider, Signer, Provider * 1
Ethers.js provides utility functions for common tasks like formatting/parsing ? and hashing (e.g., ethers.utils.formatEther, ethers.utils.keccak256) and includes a BigNumber class to handle Ethereum's large numbers, while using it or web3.js requires Node.js, the selected library, and access to an Ethereum node via a ? like INFURA, with API keys securely managed using tools like the `dotenv` module * Ether, provider * Wei, provider * Wei, cloud platform * 1
Solidity events use ?s to efficiently index and filter blockchain event logs, with the first ? representing the event signature and up to three additional ?s indexing parameters (preferably fixed-value or address-based for better filtering, rather than arbitrary strings like _author) * constraint * uri * topic * 3
In a ?, wallets like ? connect the webapp to the blockchain using libraries like ?, which create a provider and/or signer to facilitate interactions * dApp, MetaMask, ethers.js * dApp, MM, infura * blockchain, custodial, infura * 1
? is a decentralized protocol and P2P network for storing and sharing data using content-based addressing (by ?), ensuring censorship resistance and eliminating centralized points of failure (its' for ?, while ethereum is for computation) *  IPFS, storage, printable hash * ENS, analysis, CID * IPFS, analysis, printable hash * 1
In IPFS large files are chunked, hashed, and organized into? * Merkle trees * Merkle DAG objects * Elkrem trees * 2
In IPFS what happens to copies? * Copies of the same file get the same CID * Copies are replaced with references or pointers to the existing data * both of them are deduplication * 3
? uses the BitSwap protocol, inspired by BitTorrent, where a global swarm of peers exchanges small file blocks with ? incentives * IPFS, consensus * IPFS, tit-for-tat * ENS, consensus * 2
In IPFS, downloaded file blocks are cached and shared with others like in BitTorrent, with the option to ?, ensuring availability as long as someone retains it * pin data to prevent eviction * cache data * publish data in replica * 1
IPFS enables versioning with ?, using a public key hash instead of a CID to reference a file containing the public key, version number, current CID, and signature, with storage nodes retaining the latest validly signed version * Interplanetary Naming System (IPNS) * Git Naming System (GNS) * both * 1
DNSLink allows human-readable IPFS addresses by embedding an IPFS link in a DNS record, which automatically resolves to the DNS name, but... * this increase too much the space * this introduces a centralized part in the sys * this slows down the system too much * 2
IPFS uses the ? DHT for routing and content discovery, mapping peer IDs to CIDs, enabling nodes to query the DHT with a CID to locate and download content from peers storing it; doing XOR between CID and PeerID to find the closest * Chord * Kademlia * both, depending on the case * 2
?'s Triangle, a conjecture claiming names can't be meaningful, decentralized, and secure simultaneously, is disproven by solutions like the ?, which uses updateable Ethereum smart contracts to link human-readable names to Ethereum addresses * Cooko, Ethereum Name Service (ENS) * Zooko, IPNS * Zooko, Ethereum Name Service (ENS) * 3
? uses a registry to map names to resolvers (so a way to decentralize DNS: you contact a registry that tells you who is your dns provider), which are smart contracts implementing at least the addr method; the registry handles ownership, resolvers, TTLs, and events, while interacting with a Controller for registration, fees, and renewal * ENS * IPNS * IPFS * 1
If you put an img on IPFS and put the obtained CID in blockchain, what will happen? * eventually the img will expire in IPFS and therefore the on-chain CID is useless * eventually the img will expire in IPFS but your local copy will still always have the same CID due to it being an hash * there's no way to pin img to completely avoid it being discarded by IPFS * 2
Upgradable smart contracts, often via proxy contract, fix bugs and add features without redeployment, enhancing security and functionality * true * false, you need redeployment * false, they doesn't exist because smart contracts are immutable * 1
The ? opcode executes implementation contract code in the proxy’s context, ensuring consistent state during logic updates * fallback * delegatecall * callcode * 2
? functions handles calls to functions that do not exist in the contract, can receive Ethers (if defined as payable * fallback * delegatecall * callcode * 1
What happens if a sequencer ignores a transaction? * It gets discarded * The user can post it directly to L1 * It automatically retries * 2
What does a manager need to do to publish assertions in Optimistic Rollups? * Stake currency * Use zk-SNARK * Request L1 verification * 1
In Arbitrum, what happens if a validator loses the bisection game? Their stake is partially transferred to the winner and the rest is burned or given to a verifier * Their transactions are invalidated * They are removed from the network permanently * 1
What is one key difference between Optimistic Rollups and Zero-Knowledge Rollups (L2 Panorama)? Zero-Knowledge Rollups rely on optimistic assumptions, while Optimistic Rollups use cryptographic proofs * Optimistic Rollups rely on challenges, while Zero-Knowledge Rollups like zk-SNARK use cryptographic proofs for correctness, being more computationally intensive * Zero-Knowledge Rollups depend on Merkle trees, while Optimistic Rollups don’t * 2
What id dissection, an optimization of bisection for optimistic rollups? * an Arbitrum protocol * splitting in K instead of 2 * zk-Rollups * 2
What is the sequencer responsible for in Optimistic Rollups? * Running all computations * Compressing and submitting transactions * Verifying state transitions * 2
What is the sum of binary search (bisection), states stored in merkle trees and state machine replication? * Optimistic Rollups * happy path followed most of the time * both * 3
